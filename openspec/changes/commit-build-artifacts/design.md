## Context

Both `ClaudeBuilder` and `CursorBuilder` call `self._fs.remove_directory(output_dir)` before writing artifacts. This wipes the entire `.claude/` or `.cursor/` directory, destroying files not managed by promptkit — such as `settings.json`, skills from other tools (OpenSpec), or any user-created files.

The product requirements explicitly state build output should be committable to git for team standardization (Use Case 3). But the current wipe-and-rewrite strategy makes this dangerous: a `promptkit build` deletes everything else in the output directory.

Current builder code (identical pattern in both):

```python
def build(self, prompts: list[Prompt], output_dir: Path, /) -> list[Path]:
    self._fs.remove_directory(output_dir)  # <-- destroys everything
    generated: list[Path] = []
    for prompt in prompts:
        path = self._route(prompt, output_dir)
        self._fs.write_file(path, prompt.content)
        generated.append(path)
    return generated
```

## Goals / Non-Goals

**Goals:**
- Build output coexists safely with non-promptkit files in `.claude/` and `.cursor/`
- Stale promptkit-managed files from previous builds are still cleaned up
- Users can commit build artifacts to git without fear of data loss on rebuild
- Deterministic: same inputs produce same outputs (existing guarantee preserved)

**Non-Goals:**
- Merging or conflict resolution with non-promptkit files — we simply don't touch them
- Tracking which tool owns which file beyond promptkit's own manifest
- Supporting nested or overlapping output directories between platforms

## Decisions

### 1. Manifest files in `.promptkit/managed/` track generated files per platform

Each builder writes a manifest file in `.promptkit/managed/` (e.g., `claude.txt`, `cursor.txt`) listing the relative paths of all files it generated in the corresponding output directory. On the next build, it reads this manifest and removes only those files before writing new ones.

Manifests live in `.promptkit/managed/` — NOT in the output directories (`.claude/`, `.cursor/`). This keeps output directories clean with only platform-native files.

**Format**: plain text, one relative path per line (relative to the output directory), sorted. Simple and human-readable.

```
# Generated by promptkit — do not edit
# Output directory: .claude
agents/code-reviewer.md
commands/feature-dev.md
rules/code-simplifier.md
```

**Location**: `.promptkit/managed/claude.txt` for `.claude/`, `.promptkit/managed/cursor.txt` for `.cursor/`. The `.promptkit/cache/` directory is gitignored but `.promptkit/managed/` is committed.

**Rationale:** A manifest is explicit and auditable. Users can see exactly what promptkit manages. Placing it in `.promptkit/` keeps all promptkit metadata together and avoids polluting platform output directories with non-platform files.

**Alternative considered:** Manifest in the output directory (`.claude/.promptkit-managed`) — rejected because it adds a non-platform file that could confuse Claude Code or Cursor when reading the directory.

**Alternative considered:** Convention-based cleanup (e.g., only clean `rules/`, `agents/`, etc. subdirectories that promptkit knows about) — rejected because it's fragile. If a user creates a custom `agents/my-custom-agent.md` outside of promptkit, convention-based cleanup would delete it. The manifest makes ownership explicit.

**Alternative considered:** File-level markers (e.g., a comment in each generated `.md` file) — rejected because it requires reading every file to determine ownership, and modifying prompt content violates the "content preserved exactly" requirement.

### 2. Cleanup removes individual files, then empty parent directories

The builder reads the previous manifest, removes each listed file, then removes any category directories that are now empty. This avoids leaving behind empty `agents/` or `rules/` directories when prompts change between builds.

**Rationale:** Clean directories without accidentally removing directories that still have non-promptkit files in them.

### 3. Manifest files are committed to git

The `.promptkit/managed/` directory is committed to git (only `.promptkit/cache/` is gitignored). This ensures that `promptkit build` on a fresh clone knows what to clean.

**Rationale:** Without the manifest in git, a fresh clone would have build artifacts but no way to know which files to clean on the next build. Committing it keeps the system self-contained.

### 4. Missing manifest falls back to no cleanup (additive-only build)

If the platform's manifest file doesn't exist in `.promptkit/managed/` (first build, or legacy project), the builder writes artifacts without removing anything. The manifest is created on this first run for future builds.

**Rationale:** Safe default. First build on an existing project won't destroy anything. Subsequent builds use the manifest.

### 5. Builder base class extracts shared logic

Both `ClaudeBuilder` and `CursorBuilder` have identical cleanup and manifest logic. Extract a shared method or mixin rather than duplicating the manifest read/write/cleanup in both builders.

**Rationale:** DRY. The only difference between builders is the category directory mapping. The manifest lifecycle is identical.

## Risks / Trade-offs

**Manifest out of sync** → If a user manually deletes or edits the manifest in `.promptkit/managed/`, the next build won't clean stale files. Mitigation: the manifest is regenerated every build, so this only affects one build cycle. Document that the file should not be manually edited.

**First build on existing project is additive** → If an existing project has stale promptkit artifacts without a manifest, the first build won't clean them. Mitigation: acceptable — users can delete stale files manually once. All subsequent builds are clean.
