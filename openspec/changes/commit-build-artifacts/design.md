## Context

Both `ClaudeBuilder` and `CursorBuilder` call `self._fs.remove_directory(output_dir)` before writing artifacts. This wipes the entire `.claude/` or `.cursor/` directory, destroying files not managed by promptkit — such as `settings.json`, skills from other tools (OpenSpec), or any user-created files.

The product requirements explicitly state build output should be committable to git for team standardization (Use Case 3). But the current wipe-and-rewrite strategy makes this dangerous: a `promptkit build` deletes everything else in the output directory.

Current builder code (identical pattern in both):

```python
def build(self, prompts: list[Prompt], output_dir: Path, /) -> list[Path]:
    self._fs.remove_directory(output_dir)  # <-- destroys everything
    generated: list[Path] = []
    for prompt in prompts:
        path = self._route(prompt, output_dir)
        self._fs.write_file(path, prompt.content)
        generated.append(path)
    return generated
```

## Goals / Non-Goals

**Goals:**
- Build output coexists safely with non-promptkit files in `.claude/` and `.cursor/`
- Stale promptkit-managed files from previous builds are still cleaned up
- Users can commit build artifacts to git without fear of data loss on rebuild
- Deterministic: same inputs produce same outputs (existing guarantee preserved)

**Non-Goals:**
- Merging or conflict resolution with non-promptkit files — we simply don't touch them
- Tracking which tool owns which file beyond promptkit's own manifest
- Supporting nested or overlapping output directories between platforms

## Decisions

### 1. Manifest file (`.promptkit-managed`) tracks generated files

Each builder writes a `.promptkit-managed` file in the output directory listing the relative paths of all files it generated. On the next build, it reads this manifest and removes only those files before writing new ones.

**Format**: plain text, one relative path per line, sorted. Simple and human-readable.

```
# Generated by promptkit — do not edit
agents/code-reviewer.md
commands/feature-dev.md
rules/code-simplifier.md
```

**Rationale:** A manifest is explicit and auditable. Users can see exactly what promptkit manages. It's also cheap — no new dependencies, no complex data structures.

**Alternative considered:** Convention-based cleanup (e.g., only clean `rules/`, `agents/`, etc. subdirectories that promptkit knows about) — rejected because it's fragile. If a user creates a custom `agents/my-custom-agent.md` outside of promptkit, convention-based cleanup would delete it. The manifest makes ownership explicit.

**Alternative considered:** File-level markers (e.g., a comment in each generated `.md` file) — rejected because it requires reading every file to determine ownership, and modifying prompt content violates the "content preserved exactly" requirement.

### 2. Cleanup removes individual files, then empty parent directories

The builder reads the previous manifest, removes each listed file, then removes any category directories that are now empty. This avoids leaving behind empty `agents/` or `rules/` directories when prompts change between builds.

**Rationale:** Clean directories without accidentally removing directories that still have non-promptkit files in them.

### 3. Manifest file is committed to git

The `.promptkit-managed` file lives alongside the build artifacts in `.claude/` or `.cursor/` and should be committed. This ensures that `promptkit build` on a fresh clone knows what to clean.

**Rationale:** Without the manifest in git, a fresh clone would have build artifacts but no way to know which files to clean on the next build. Committing it keeps the system self-contained.

### 4. Missing manifest falls back to no cleanup (additive-only build)

If `.promptkit-managed` doesn't exist (first build, or legacy project), the builder writes artifacts without removing anything. The manifest is created on this first run for future builds.

**Rationale:** Safe default. First build on an existing project won't destroy anything. Subsequent builds use the manifest.

### 5. Builder base class extracts shared logic

Both `ClaudeBuilder` and `CursorBuilder` have identical cleanup and manifest logic. Extract a shared method or mixin rather than duplicating the manifest read/write/cleanup in both builders.

**Rationale:** DRY. The only difference between builders is the category directory mapping. The manifest lifecycle is identical.

## Risks / Trade-offs

**Manifest out of sync** → If a user manually deletes or edits `.promptkit-managed`, the next build won't clean stale files. Mitigation: the manifest is regenerated every build, so this only affects one build cycle. Document that the file should not be manually edited.

**Extra file in output directory** → `.promptkit-managed` is a new file that appears in `.claude/` and `.cursor/`. Mitigation: it's small, clearly named, and has a comment header explaining its purpose.

**First build on existing project is additive** → If an existing project has stale promptkit artifacts without a manifest, the first build won't clean them. Mitigation: acceptable — users can delete stale files manually once. All subsequent builds are clean.
