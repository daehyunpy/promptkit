"""Infrastructure layer: Manifest-based tracking of generated build artifacts."""

from pathlib import Path

MANAGED_DIR = ".promptkit/managed"
MANIFEST_HEADER = "# Generated by promptkit â€” do not edit"


def read_manifest(project_dir: Path, platform_name: str, /) -> list[str]:
    """Read the manifest for a platform, returning relative paths.

    Returns an empty list if the manifest file does not exist.
    """
    manifest_path = project_dir / MANAGED_DIR / f"{platform_name}.txt"
    if not manifest_path.exists():
        return []
    return [
        line
        for line in manifest_path.read_text().splitlines()
        if line and not line.startswith("#")
    ]


def write_manifest(project_dir: Path, platform_name: str, paths: list[str], /) -> None:
    """Write a sorted manifest of generated file paths for a platform."""
    manifest_path = project_dir / MANAGED_DIR / f"{platform_name}.txt"
    manifest_path.parent.mkdir(parents=True, exist_ok=True)
    lines = [MANIFEST_HEADER] + sorted(paths)
    manifest_path.write_text("\n".join(lines) + "\n")


def cleanup_managed_files(output_dir: Path, manifest_paths: list[str], /) -> None:
    """Remove previously managed files and prune empty parent directories."""
    removed_parents: set[Path] = set()

    for relative in manifest_paths:
        target = output_dir / relative
        if target.is_file():
            removed_parents.add(target.parent)
            target.unlink()

    # Prune empty directories bottom-up
    for parent in sorted(removed_parents, key=lambda p: len(p.parts), reverse=True):
        _prune_empty_parents(parent, output_dir)


def _prune_empty_parents(directory: Path, stop_at: Path, /) -> None:
    """Remove empty directories walking up to (but not including) stop_at."""
    current = directory
    while current != stop_at and current.is_dir() and not any(current.iterdir()):
        current.rmdir()
        current = current.parent
